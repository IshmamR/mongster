import type { Binary, Decimal128, Double, Int32, ObjectId } from "bson";
import type { Filter } from "mongodb";
import type { MongsterSchemaBase, OptionalSchema, WithDefaultSchema } from "../schema/base";
import type { Prettify } from "./types.common";

export type Primitives = string | number | boolean;
export type Builtins = Primitives | Date | Buffer;
export type BsonTypes = ObjectId | Decimal128 | Double | Binary | Int32;
export type Nullish = null | undefined;

export type NoExpandType = Builtins | BsonTypes | Nullish;

export type ResolveTuple<T extends readonly unknown[]> = T extends readonly []
  ? readonly []
  : T extends readonly [infer H, ...infer R]
    ? readonly [Resolve<H>, ...ResolveTuple<R>]
    : never;

export type Resolve<T> = T extends NoExpandType
  ? T
  : T extends readonly [unknown, ...unknown[]]
    ? ResolveTuple<T> // fixed tuple
    : T extends readonly (infer U)[]
      ? Resolve<U>[] // variable-length array
      : T extends object
        ? { [K in keyof T]: Resolve<T[K]> }
        : T;

type RequiredOutputs<T extends Record<string, MongsterSchemaBase<any>>> = {
  [K in keyof T as T[K] extends OptionalSchema<any> ? never : K]: T[K]["$type"];
};
type OptionalOutputs<T extends Record<string, MongsterSchemaBase<any>>> = {
  [K in keyof T as T[K] extends OptionalSchema<any> ? K : never]?: T[K] extends OptionalSchema<
    infer U
  >
    ? U
    : never;
};
export type ObjectOutput<T extends Record<string, MongsterSchemaBase<any>>> = RequiredOutputs<T> &
  OptionalOutputs<T>;

type RequiredInputs<T extends Record<string, MongsterSchemaBase<any>>> = {
  [K in keyof T as T[K] extends OptionalSchema<any> | WithDefaultSchema<any>
    ? never
    : K]: T[K]["$input"];
};
type DefaultInputs<T extends Record<string, MongsterSchemaBase<any>>> = {
  [K in keyof T as T[K] extends WithDefaultSchema<any> ? K : never]?: T[K]["$input"];
};
export type ObjectInput<T extends Record<string, MongsterSchemaBase<any>>> = RequiredInputs<T> &
  OptionalOutputs<T> &
  DefaultInputs<T>;

export type ValidatorFunc<T> = (v: T) => boolean;

export type MongsterIndexDirection = 1 | -1 | "hashed" | "text";
export interface MongsterIndexOptions<Collection> {
  /** Creates an unique index. */
  unique?: boolean;
  /** Creates a sparse index. */
  sparse?: boolean;
  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */
  partialFilterExpression?: Filter<Collection>;
  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */
  expireAfterSeconds?: number;
  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */
  name?: string;
  default_language?: string;
  weights?: Document;
  /** Creates the index in the background, yielding whenever possible. */
  background?: boolean;
  /** Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher) */
  storageEngine?: Document;
  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the "w" field in a write concern plus "votingMembers", which indicates all voting data-bearing nodes. */
  commitQuorum?: number | string;
  /** Specifies the index version number, either 0 or 1. */
  version?: number;
  language_override?: string;
  textIndexVersion?: number;
  "2dsphereIndexVersion"?: number;
  bits?: number;
  /** For geospatial indexes set the lower bound for the co-ordinates. */
  min?: number;
  /** For geospatial indexes set the high bound for the co-ordinates. */
  max?: number;
  bucketSize?: number;
  wildcardProjection?: Document;
  /** Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher) */
  hidden?: boolean;
}

export interface SchemaMeta<Collection> {
  index?: MongsterIndexDirection;
  options: MongsterIndexOptions<Collection>;
}

export type TimestampKeys = "createdAt" | "updatedAt";

export type WithTimestamps<O> = Prettify<O & { [K in TimestampKeys & string]: Date }>;

export interface MongsterSchemaOptions {
  withTimestamps?: boolean;
}

/**
 * Infer the type from any given mongster schema
 */
export type InferSchemaType<MS extends MongsterSchemaBase<any>> = Prettify<
  MS["$type"] extends Record<"_id", any> ? MS["$type"] : { _id: ObjectId } & MS["$type"]
>;

type ContainsAll<T, U> = Exclude<U, T> extends never ? true : false;
export type InferSchemaInputType<MS extends MongsterSchemaBase<any>> =
  ContainsAll<keyof MS["$input"], TimestampKeys> extends true
    ? Prettify<Omit<MS["$input"], TimestampKeys> & { [K in TimestampKeys]?: Date }>
    : MS["$input"];
